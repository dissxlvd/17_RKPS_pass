# Задание на допуск по дисциплине "Разработка Кроссплатформенных Программных Систем" (РКПС)

### Содержание

[Информация о проекте](#информация-о-проекте)  
[1. Установка](#1-установка)  
[2. Спецификация УВМ](#2-спецификация-увм-учебной-виртуальной-машины)

- [2.1. Команды](#21-доступные-команды)
- [2.2. Язык ассемблера](#22-язык-ассемблера)

## Информация о проекте

Согласно списку группы, выбран **17 вариант** задания.

Для разработки УВМ был выбран язык программирования **Python**, GUI приложение на ОС Windows и ОС Linux (в частности дистрибутив **[Fedora Linux](https://fedoraproject.org/)**) реализовано при помощи GUI фреймворка **[PyQt](https://www.riverbankcomputing.com/software/pyqt/)**, Web-приложение было реализовано на языке программирования **Python** с использованием **JavaScript** и фреймворком **[Flask](https://flask.palletsprojects.com/en/stable/)**.

<sub><span style="opacity: 50%; color: orange">[ ! ] Обратите внимание: Задание выполнялось локально и поэтапно, некоторые изменения в проекте могут отсутсвовать в коммит логе.</span></sub>

## 1. Установка

Здесь пока пусто

---

<sub>[Вернуться к началу пункта](#1-установка)</sub>  
<sub>**[Наверх](#задание-на-допуск-по-дисциплине-разработка-кроссплатформенных-программных-систем-ркпс)**</sub>

## 2. Спецификация УВМ (Учебной виртуальной машины)

Учебная Виртуальная Машина (далее УВМ) имеет порядок байтов little-endian, что означает что наименее значимые биты записываются первыми. Например число 42 будет записано как:

<table>
<tr>
	<th>Порядок</th>
	<th>Binary</th>
	<th>Hex</th>
</tr>
<tr>
	<td>big-endian</td>
	<td>00<b>101010</b> (32 + 8 + 2)</td>
	<td>0x<b>2A</b>00</td>
</tr>
<tr>
	<td>little-endian</td>
	<td><b>010101</b>00 (2 + 8 + 32)</td>
	<td>0x00<b>2A</b></td>
</tr>
<table>

### 2.1. Доступные команды

- [Загрузка константы (ldc)](#загрузка-константы)
- [Чтение значения из памяти (ldm)](#чтение-значения-из-памяти)
- [Запись значения в память (stm)](#запись-значения-в-память)
- [Бинарная операция _max()_ (max)](#бинарная-операция-max)

#### Загрузка константы

<table>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>

<tr>
<td>Биты 0 - 4</td>
<td>Биты 5 - 26</td>
<td>Биты 27 - 42</td>
</tr>

<tr>
<td>13</td>
<td>Адрес</td>
<td>Константа</td>
</tr>
</table>

**_Размер команты:_** 6 байт (48 бит).  
**_Операнд:_** поле C.  
**_Результат:_** значение в памяти по адресу, которым является поле B.

Test case: (A = 13, B = 492, C = 964)  
Expected result: 0x8d, 0x3D, 0x00, 0x20, 0x1E, 0x00

#### Чтение значения из памяти

<table>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>

<tr>
<td>Биты 0 - 4</td>
<td>Биты 5 - 26</td>
<td>Биты 27 - 48</td>
</tr>

<tr>
<td>31</td>
<td>Адрес</td>
<td>Адрес</td>
</tr>
</table>

**_Размер команты:_** 7 байт (56 бит).  
**_Операнд:_** значение в памяти по адресу, которым является значение в памяти по адресу, которым является поле C.  
**_Результат:_** значение в памяти по адресу, которым является поле B.

Test case: (A = 31, B = 615, C = 854)  
Expected result: 0xFF, 0x4C, 0x00, 0xB0, 0x1A, 0x00, 0x00

#### Запись значения в память

<table>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>

<tr>
<td>Биты 0 - 4</td>
<td>Биты 5 - 26</td>
<td>Биты 27 - 48</td>
</tr>

<tr>
<td>7</td>
<td>Адрес</td>
<td>Адрес</td>
</tr>
</table>

**_Размер команты:_** 7 байт (56 бит).  
**_Операнд:_** Значение в памяти по адресу, которым является поле B.  
**_Результат:_** значение в памяти по адресу, которым является поле C.

Test case: (A = 7, B = 57, C = 8)  
Expected result: 0x27, 0x07, 0x00, 0x40, 0x00, 0x00, 0x00

#### Бинарная операция _max()_

<table>
<tr>
	<th>A</th>
	<th>B</th>
	<th>C</th>
	<th>D</th>
</tr>

<tr>
	<td>Биты 0 - 4</td>
	<td>Биты 5 - 26</td>
	<td>Биты 27 - 48</td>
	<td>Биты 49 - 70</td>
</tr>

<tr>
	<td>28</td>
	<td>Адрес</td>
	<td>Адрес</td>
	<td>Адрес</td>
</tr>
</table>

**_Размер команты:_** 9 байт (72 бит).  
**_Первый Операнд:_** значение в памяти по адресу, которым является поле B.  
**_Второй Операнд:_** значение в памяти по адресу, которым является поле D.  
**_Результат:_** значение в памяти по адресу, которым является поле C.

Test case: (A = 28, B = 481, C = 498, D = 184)  
Expected result: 0x3C, 0x3C, 0x00, 0x90, 0x0F, 0x00, 0x70, 0x01, 0x00

### 2.2. Язык ассемблера

При проектировании языка ассемблера было принято решение взять за основу набор инструкций 8-битного микропроцессора **MOS Technology 6502**

Требуемые команды были обозначены следующим образом:

<table>
<tr>
	<th>Команда</th>
	<th>Мнемоника</th>
	<th>Формат</th>
	<th>Действие</th>
</tr>
<tr>
	<td>Загрузка константы</td>
	<td>ldc (<b>L</b>oa<b>D</b> <b>C</b>onstant)</td>
	<td>ldc <i>&lt;destination&gt; &lt;constant&gt;</i></td>
	<td>Загрузить значение &lt;constant&gt; по адресу &lt;destination&gt; (C -> A)</td>
</tr>
<tr>
	<td>Чтение значения из памяти</td>
	<td>ldm (<b>L</b>oa<b>D</b> from <b>M</b>emory)</td>
	<td>ldm <i>&lt;destination&gt; &lt;source&gt;</i></td>
	<td>Загрузить из адреса &lt;source&gt; по адресу &lt;destination&gt; (M -> A)</td>
</tr>
<tr>
	<td>Запись значения в память</td>
	<td>stm (<b>S</b><b>T</b>ore to <b>M</b>emory)</td>
	<td>stm <i>&lt;source&gt; &lt;destination&gt;</i></td>
	<td>Записать из адреса &lt;source&gt; по адресу &lt;destination&gt; (A -> M)</td>
</tr>
<tr>
	<td>Бинарная операция <i>max()</i></td>
	<td>max</td>
	<td>max <i>&lt;destination&gt; &lt;op_1&gt; &lt;op_2&gt;</i></td>
	<td>Записать в адрес &lt;destination&gt; максимум из значений &lt;op_1&gt; &lt;op_2&gt;</td>
</tr>
</table>

---

<sub>[Вернуться к началу пункта](#2-спецификация-увм-учебной-виртуальной-машины)</sub>  
<sub>**[Наверх](#задание-на-допуск-по-дисциплине-разработка-кроссплатформенных-программных-систем-ркпс)**</sub>
